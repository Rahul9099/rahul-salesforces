Approach for triggers:--
1) read the question 3 times
2) always try to use variables to store values instead of parent child
3) if not 2 applicable go with parent child
4) break the parent child go with map and set like sir did
5) after writing try to dry run 



Mostly asked interview questions :-
1) only system admin should be able to delete the record
trigger ContactTrigger on Contact (before insert, after insert, before update, after update, before delete, after delete, after undelete) {
    if (Trigger.isBefore && Trigger.isDelete) {
        List<Profile> systemId = [SELECT Id FROM Profile WHERE Name = 'System Administrator'];
        Set<Id> sidset = new Set<Id>();
        for (Profile p : systemId) {
            sidset.add(p.Id);
        }
        List<Contact> dellist = new List<Contact>();
        for (Contact wc : Trigger.old) {
            if (sidset.contains(UserInfo.getProfileId())) {
                dellist.add(wc);
            } else {
                wc.addError('You cannot delete');
            }
        }
        if (!dellist.isEmpty()) {
            System.debug('Contacts to be deleted: ' + dellist);
            delete dellist;
        }
    }
}
                                            correct one bellow
trigger ContactTrigger on Contact (before insert, after insert, before update, after update, before delete, after delete, after undelete) {
    if (Trigger.isBefore && Trigger.isDelete) {
        List<Profile> systemId = [SELECT Id FROM Profile WHERE Name = 'System Administrator'];
        Set<Id> sidset = new Set<Id>();
        for (Profile p : systemId) {
            sidset.add(p.Id);
        }
        List<Contact> dellist = new List<Contact>();
        for (Contact wc : Trigger.old) {
            if (!sidset.contains(UserInfo.getProfileId())) {
                wc.addError('You cannot delete');                
            } 
        }
    }
}

--alternate 
--questions::-How to write trigger that Only administrators must be able to delete events and tasks with status = 'Completed' or 'Open'?
Ans:-
There's no reason to delete the tasks a second time; they're already on their way to the recycle bin when this trigger executes.

For your main question, you can check the type of WhatId:

taskObj.WhatId != null && taskObj.WhatId.getSObjectType() == Opportunity.SObjectType

Your overall trigger could be written as follows:

trigger NoDeleteOnTask on Task (before delete) {
    if([Select Profile.Name FROM User WHERE Id = :UserInfo.getUserId()]
       .Profile.Name != 'System Administrator']) {
        for(Task record: Trigger.old) {
            if(record.WhatId != null &&
               (record.Status == 'Completed' || record.Status == 'Open') &&
               record.WhatId.getSObjectType() == Opportunity.SObjectType) {
                record.addError('Only admins can delete a task that is not open or completed for an opportunity.');
            }
        }
    }
}


Question No-2 :- create  a roll up summary 

(Pending for now --)


                                                                                       *********Trigger sheet  questions************ 

1)When we are trying to insert new record into object. If there is any record existing with 
same account name it should prevent duplicate record
Ans:-

if(trigger.isBefore && trigger.isInsert){
accounthandler.validate(trigger.new);
}

public static void validate(list<account>aclist){
set<string>nameset = new set<string>();
if(!aclist.isEmpty()){
for(account a:aclist){
nameset.add(a.name);
}
list<account>aclist2=[select id from account where name in: nameset];
set<string> duplicateset =new set<string>();
for(account a:aclist2){
duplicateset .add(a.name);
}
for(account a: aclist){
if(duplicateset.contains(a.name)){
a.addError('user name already exist');
}
}

2) duplicate [email & phone] if exist then add error





3): Whenever a new contact is created for account update the corresponding account phone with the new contact phone field.
Ans:-- 
  public static void accupdate(list<contact>clist){
        map<id,contact> cmap = new map<id,contact>();
        for(contact c: clist){
            if(c.AccountId!=null && c.Phone!=null){
                cmap.put(c.AccountId,c);
            }
        }
        list<account>aclist=[select id,name,phone From account where id in: cmap.keyset()];
        for(account a:aclist){
            a.Phone = cmap.get(a.id).phone;
        }
        update aclist;
    }


4)Whenever we try to update the phone of account record then update the related 
contact phone number with the new Account phone number before account record is updated.
When we delete the account record then delete the corresponding contact records.
Ans::-
public static void realtedContactPhoneUpdate(list<account>aclist,map<id,account>acmap){
        map<id,string> acmap2 = new map<id,string>();
        for(account a:aclist){
            if(a.Phone!=acmap.get(a.id).phone){
                acmap2.put(a.id,a.Phone);
            }
        }
        list<contact>clist=[select id,phone,accountId from contact where accountId in:acmap2.keyset()];
        for(contact c:clist){
            c.Phone = acmap2.get(c.AccountId);
        }
        update clist;
    }

---recursive trigger flow:-
theory: - contact trigger::-- jab ek new contact insert hoga tab ek new account bhe insert ho. but account trigger:-- jab ek new account insert ho tab ek new contact bhe insert ho. ayse case m ek trigger dusre trigger ko call krte rahega jab tak Maximum trigger depth exceeded nhe aye

eg:-
public class Utility {

    public static boolean isTriggerTrue = true;
}
------------------------
contact trigger contrigger (after insert){
if(trigger.isAfter){
        if(trigger.isInsert){
            if(Utility.isTriggerTrue){
                Utility.isTriggerTrue = false;
                ContactTriggerHandler.contactRecusion(trigger.new);
            }
}
public static void contactRecusion(list<contact>clist){
        list<account>alist = new list<account>();
        for(contact c: clist){
            account a = new account();
            a.Name='account ->contact rec';
            alist.add(a);
        }
        insert alist;
    }
account trigger acctrigger(after insert){
if(trigger.isAfter){
        if(trigger.isInsert){    
            if(Utility.isTriggerTrue){
                Utility.isTriggerTrue = false;
                AccountTriggerHandler.createContactRec(trigger.new);
            }
       
        }
}
  public static void createContactRecursion(list<account>aclist){
        list<contact>clist = new list<contact>();
        for(account a: aclist){
            contact c = new contact();
            c.LastName = 'rec contact 1';
            c.AccountId = a.Id;
            clist.add(c);
        }
        insert clist;
    }

Note:--
1)---jab apn  Static Boolean is an anti-pattern so please DO NOT USE krte hai to yeah sirf 200 records k liye chalega but not for large record eg:- mere org me 400 record hai ur pehle 200 ke liye chala but badme false ho gaya next 200 k liye nhe chalega 
 
2)-- https://www.apexhours.com/trigger-framework-in-salesforce/

3)






                                                                                       *********Youtube questions************ 

7) Trigger to create a realted contact of account with same phone as account phone if checkbox is check on account
Ans::-
if(tigger.isAfter){
if(trigger.isInsert){
questionSeven(trigger.new,null);
}
if(trigger.isUpdate){
questionSeven(trigger.new,trigger.oldmap);
}
 public static void questionSeven(list<account>aclist,map<id,account>acmap){
        set<id> acset =new set<id>();
        list<contact> clist = new list<contact>();
        if(acmap==null){
            for(account a:aclist){
                if(a.Active__c == true){
                    contact c= new contact();
                    c.LastName = a.Name;
                    c.Phone = a.Phone;
                    c.AccountId=a.id;
                    clist.add(c);
                }
            }  
        }
        
        if(acmap!=null){
            for(account a:aclist){
                if(a.Active__c != acmap.get(a.id).Active__c){
                    if(a.Active__c == true){
                        contact c= new contact();
                        c.LastName = a.Name;
                        c.Phone = a.Phone;
                        c.AccountId=a.id;
                        clist.add(c);
                    }                    
                }
            }
        }        
    }



questions 8)Trigger to sum all realted opportunties amount of an account
Ans:-
public with sharing class TriggerOneFifty {
// opportunity rollup 
    public static void OpportunityRollUp(list<Opportunity>opplist,map<id,opportunity>oldmap){
        //insert ,undelte
        set<id> accountIdSet = new set<id>(); 
        if(oldmap==null && !opplist.isEmpty()){
            for(opportunity opp: opplist){
                if(opp.accountId!=null){
                    accountIdSet.add(opp.accountId);
                }
            }
        }
        if(oldmap!=null && !opplist.isEmpty()){
            for(opportunity opp: opplist){
                if(opp.accountId!=null && oldmap.get(opp.id).accountID != opp.accountId){
                    accountIdSet.add(opp.accountId);
                    accountIdSet.add(oldmap.get(opp.id).accountID);
                }
            }
        }  
        list<AggregateResult> result = [select id,accountID,count(id) oppcount,sum(amount) total,
                                         min(amount) minAmount, max(amount) maxAmount FROM opportunity 
                                         where accountId in: accountIdSet group by accountId];
        list<account> accountToUpdateList = new list<account>();
        for(AggregateResult arg:result){
            account acc = new account();
            acc.id =(Id) arg.get(accountID);
            acc.min__c =(decimal) arg.get(minAmount);
            acc.max__c = (decimal) arg.get(maxAmount);
            acc.countOpp__c = (Integer) arg.get(oppcount);
            acc.total__c = (decimal) arg.get(total);
            accountToUpdateList.add(acc);      
        }
        if(!accountToUpdateList.isEmpty()){
            update accountToUpdateList;
        }
        }
    }
}





----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
class wrap {

}

public with sharing class OpportunityTriggerHandler {

public static void rollupSumOppToAcc(list<Opportunity> oppNewList){

set<Id>accountIdSet = new set<Id>();

for(Opportunity opp = oppNewList){
if(opp.AccountId != null){
accountIdSet.add(opp.AccountId);
}
}

list<Opportunity> resultList = [SELECT Id,AccountId,Amount FROM Opportunity 
                                              WHERE AccountId IN: accountIdSet ORDER BY AccountId
                                               WITH SECURITY_ENFORCED];
Map<Id,Opportunity> resultMap = new Map<Id,Opportunity>();

if(!resultList.isEmpty()){

string tempAccountId;
for(Opportunity opp : resultList){
  if(tempAccountId == null){
    tempAccountId = opp.AccountId;
  }
  
}


}
 

}


}







----------------------------------------------------------------------------------------100 trigger target to achive -------------------------------------------------------------------
41+25=66

yt_SFDC_NIN 41) two object account and opportunity on acc-max closed opp amount 
scenerio is :- update max closed opp amount  field on account when [opp is (creat,update,delete)] without using aggregate query

my approach:-
    //dumb ways to die 
    public static void maxOpprtunity(list<Opportunity>opplist){
        set<id>accountIdSet = new set<id>();
        for(opportunity opp :opplist){
            if(opp.AccountId !=null){
                accountIdSet.add(opp.AccountId);
            }
        }
       list<account> resultList =[select id,(select id,accountId from opportunities)from account where id in: accountIdSet];
       list<account> listToUpdate = new list<account>();
        for(account acc: resultList){
            decimal max = 0;
            for(opportunity opp: acc.opportunities){
                if(opp.Amount > max){
                    max = opp.Amount;
                }
            }
           acc.max__c =max;
           listToUpdate.add(acc);
        }
        update listToUpdate;
    }
 
Mistakes:- didnot use map for storing , get confused in data getting retrived , need clear visual data query representation

easy trick:-
public static void maxOpprtunity(list<Opportunity>opplist){
        set<id>accountIdSet = new set<id>();
        for(opportunity opp :opplist){
            if(opp.AccountId !=null){
                accountIdSet.add(opp.AccountId);
            }
        }
       list<account> resultList =[select id,(select id,accountId,amount from opportunities order by amount limit 1)from account where id in: accountIdSet];
       list<account> listToUpdate = new list<account>();
        for(account acc: resultList){
            for(opportunity opp: acc.opportunities){
                 acc.maxAmount__c = opp.amount;
            }
           listToUpdate.add(acc);
        }
        update listToUpdate;
    }


trigger OpportunityTrigger on Opportunity (before insert,before update,before delete,after undelete,after insert,after update,after delete) {

}

public with sharing class OpportunityTriggerHandler {

}




Scenario 1 : When we are trying to insert new record into object. If there is any record existing with 
same account name it should prevent duplicate record.


trigger AccountTrigger on Account (before insert,before update,before delete,after undelete,after insert,after update,after delete) {

if(trigger.isBefore){
    AccountTriggerHandler.preventDuplicate(trigger.new);
}

}

public with sharing class AccountTriggerHandler {

  public static void preventDuplicate(list<Account> newAccountList){
        set<String> nameSet = new set<String>();
        if(!newAccountList.isEmpty()){
            for(Account acc : newAccountList){
                if(acc.name !=null){
                    nameSet.add(acc.Name);
                }
            }
        }
        
         list<Account> resultList = [SELECT Id,Name FROM Account WHERE Name IN: nameSet WITH SECURITY_ENFORCED];
        set<String> resultSet =new set<String>();
        if(!resultList.isEmpty()){
            for(Account acc: resultList){
                if(acc.name != null){
                    resultSet.add(acc.Name);
                }
            }
        }
        if(!newAccountList.isEmpty()){
            for(Account acc : newAccountList){
                if(acc.name !=null && resultSet.contains(acc.Name)){
                    acc.addError('This Account Name is Already Present In Database');
                }
            }
        }
    }

}


Scenario 3: Whenever a new record is created into account object . Before this new record is 
inserted into Account, delete all the contacts records with this account name.

trigger AccountTrigger on Account (before insert,before update,before delete,after undelete,after insert,after update,after delete) {

if(trigger.isAfter){
    AccountTriggerHandler.deleteContactSameAccountName(trigger.new);
}

}

public with sharing class AccountTriggerHandler {

 public static void deleteContactSameAccountName(list<Account> newAccountList){
        set<String> nameSet = new set<String>();
        if(!newAccountList.isEmpty()){
            for(Account acc : newAccountList){
                if(acc.name !=null){
                    nameSet.add(acc.Name);
                }
            }
        }
   
        list<contact> conList = [SELECT Id, Name FROM Contact WHERE Name IN: nameSet WITH SECURITY_ENFORCED];
        
       if(!conList.isEmpty()){
           try{
            delete conList;
                }catch(Exception e){
             System.debug('Exception Occur'+e.getMessage());
            }
}


Scenario 4: Whenever a new transaction is performed successfully then update the customer object 
balance field based on 
If Transaction Type=Deposit, Balance= balance +amount ; withdraw balance= balance-amount;
Note: Customers and Transaction has lookup Detail Relation.

trigger AccountTrigger on transaction (before insert,before update,before delete,after undelete,after insert,after update,after delete) {

if(trigger.isAfter){
    transactionTriggerHandler.updateCustomerBalance(trigger.new);
}

}

public with sharing class transactionTriggerHandler {

public static void updateCustomerBalance(list<Transaction> newTransactionList){
        //step :- 1 update parent wale questions me parentId store karao

        set<Id> customerIdSet = new set<Id>();
        if(!newTransactionList.isEmpty()){
            for(Transaction tr : newTransactionList){
                if(tr.customerID !=null){
                    newTransactionList.add(tr.cutomerID);
                }
            }
        }
       //step 2:- create a map of which parent field to update

       map<id,cutomer__c> cutomerMap = new map<id,cutomer__c>([SELECT Id,Balance FROM Cutomer__c WHERE Id IN: customerIdSet WITH SECURITY_ENFORCED]);
       list<Customer__c> customerUpdateList = new list<Customer__c>();
       if(!newTransactionList.isEmpty()){
            for(Transaction tr : newTransactionList){
                if(tr.customerID !=null && customerMap.containsKey(tr.customerId)){

                   //step 3 list bano ur useme add karo jo update krne hai

                   Customer__c cust = cutomerMap.get(tr.customerId);
                    if(tr.type == 'Deposite'){
                        cust.Balance__c = cust.Balance__c + tr.amount;
                    }
                    if(tr.type == 'withdraw'){
                        if(cust.Balance__c >= tr.amount){
                           cust.Balance__c = cust.Balance__c - tr.amount; 
                        }
                    }
                    else{
                        
                    }
                    customerUpdateList.add(cust);
                }
            }
        }
        // if bance is 0 and withdraw is negative then
        if(!customerUpdateList.isEmpty()){
            update customerUpdateList;
        }
}



Scenario 5: Whenever a new contact is created for account update the corresponding account phone with the new contact phone field.

trigger AccountTrigger on contact (before insert,before update,before delete,after undelete,after insert,after update,after delete) {

if(trigger.isAfter){
    ContactTriggerHandler.updateAccountPhone(trigger.new);
}

}

public with sharing class ContactTriggerHandler{
 public static void updateRelatedAccount (list<Contact> newContactList){
        set<Id> accountIdSet = new set<Id>();
        set<Id> contactIdSet = new set<Id>();
        if(!newContactList.isEmpty()){
            for(Contact con: newContactList){
                if(con.AccountId != null){
                    accountIdSet.add(con.AccountId);
                    contactIdSet.add(con.Id);
                }
            }
        }
       list<Account> resultAccountList =[SELECT Id,Phone,(SELECT Id,Phone FROM Contacts WHERE Id IN: contactIdSet) FROM Account WHERE Id IN: accountIdSet];
       list<Account> AccountToUpdate = new list<Account>();
        if(!resultAccountList.isEmpty()){
            for(Account acc: resultAccountList){
                for(contact c:acc.contacts){
                    acc.phone = c.phone;
                    AccountToUpdate.add(acc);
                }
            }
        }
        update AccountToUpdate;
    }
}

Notes:- the above thing will work but time complexity O(n(sqr))
also if two contact will be upload on same account then consider the last one 
optimize :- update parent on child store parent field to update in map then update
the below code is optimum approach to solve 

  public static void updateRelatedAccount (list<Contact> newContactList){
        set<Id> accountIdSet = new set<Id>();
        if(!newContactList.isEmpty()){
            for(Contact con: newContactList){
                if(con.AccountId != null && con.Phone != null){
                    accountIdSet.add(con.AccountId);
                }
            }
        }
       map<Id,Account> resultAccountMap = new map<Id,Account>([SELECT Id,Phone From Account WHERE Id IN: accountIdSet ]);
       list<Account> accountToUpdateList = new list<Account>();
        for(contact con : newContactList){
          if(con.AccountId != null && con.Phone != null){
              if(resultAccountMap.containsKey(con.AccountId)){
                  Account acc = resultAccountMap.get(con.AccountId);
                  acc.phone = con.Phone;
                 accountToUpdateList.add(acc); 
              }    
           }  
        }
        if(!accountToUpdateList.isEmpty()){
            update accountToUpdateList; 
        }
    }

-------also another way to solve------
 public static void updateRelatedAccount (list<Contact> newContactList){
        list<Account> accountToUpdateList = new list<Account>();
        if(!newContactList.isEmpty()){
            for(Contact con: newContactList){
                if(con.AccountId != null && con.Phone != null){
                    Account acc = new Account();
                    acc.Id = con.AccountId;
                    acc.Phone = con.Phone;
                    accountToUpdateList.add(acc);
                }
            }
        }
       update accountToUpdateList;
    }




Scenario 6: Whenever customer record is updated, before updating the record create new record in test object with old values of customer record.


trigger AccountTrigger on customer (before insert,before update,before delete,after undelete,after insert,after update,after delete) {

if(trigger.isAfter){
    if(trigger.isUpdate){
         CustomerTriggerHandler.createBackupInTest(trigger.new);
   }
}

public class with sharing CustomerTriggerHandler{

public static void createBackupInTest(list<customer> newCutomerList){
list<Test> testToUpdateList = new list<Test>();
if(Customer con: newCutomerList){
test t = new test();
t.name = con.name;
testToUpdateList.add(t);
}
}
update testToUpdateList;

}


scenerio :- write a trigger to prevent duplicate in account if same email exist in contact and lead 

trigger AccountTrigger on account (before insert,before update,before delete,after undelete,after insert,after update,after delete) {

if(trigger.isBefore){
    if(trigger.isInsert){
         AccountTriggerHandler.preventDuplicate(trigger.new);
   }
}

public class with sharing  AccountTriggerHandler{

    public static void preventDuplicateEmail(list<Account> newAccountList){
        set<String> accountEmailSet = new set<String>();
        if(!newAccountList.isEmpty()){
            for(Account acc: newAccountList){
                if(acc.Email__c !=null){
                   accountEmailSet.add(acc.Email__c); 
                }
            }    
        }   
        list<Contact> resultContactList = [SELECT Email FROM Contact WHERE Email IN:accountEmailSet];
        list<Lead> resultLeadList = [SELECT Email FROM Lead WHERE Email IN:accountEmailSet];
        set<String> resultEmailSet = new set<String>();
        if(!resultContactList.isEmpty() || !resultLeadList.isEmpty()){
            for(Contact c : resultContactList){
                resultEmailSet.add(c.Email);
            }
            for(Lead c : resultLeadList){
                resultEmailSet.add(c.Email);
            }
        }
       if(!newAccountList.isEmpty()){
            for(Account acc: newAccountList){
                if(acc.Email__c !=null && resultEmailSet.contains(acc.Email__c){
                    acc.addError('Please Enter New Email');
                }
            }    
        } 
    }


17. How would you use a trigger to prevent specific users from deleting certain records?

A Salesforce trigger can be used to prevent specific users from deleting certain records by implementing a ‘before delete’ trigger. This trigger will fire before the deletion of a record, allowing us to check if the user has the necessary permissions.

Here’s an example:
trigger PreventDelete on ObjectName (before delete) {
    for(ObjectName record : Trigger.old){
        if(UserInfo.getUserId() == record.OwnerId && !UserInfo.getProfileId().equals('PROFILE_ID')){
            record.addError('You do not have permission to delete this record.');
        }
    }
}

In this code, we’re checking each record that is about to be deleted. If the current user is the owner of the record and their profile ID does not match the allowed profile ID, we add an error to the record which prevents it from being deleted. Replace ‘ObjectName’ with the name of your object and ‘PROFILE_ID’ with the ID of the profile you want to allow deletions.


24. How would you use a Salesforce Trigger to integrate with an external system?

A Salesforce Trigger can be used to integrate with an external system by creating a trigger on the object that needs integration. When a record is created, updated or deleted, this trigger fires and calls a class method which makes HTTP callouts to the external system’s API.

The Apex code for the trigger would look something like:
trigger MyTrigger on MyObject (after insert, after update) {
    ExternalSystemClass.sendToExternalSystem(Trigger.new);
}

In ExternalSystemClass
, you’d have a sendToExternalSystem
method making HTTP callouts. It’s important to remember that since triggers are transactional, we must use asynchronous callouts (@future
methods) to avoid mixed DML operation errors.

Also, error handling should be implemented in the class method to ensure smooth operation and proper data synchronization between Salesforce and the external system.





trigger AccountTrigger on account (before insert,before update,before delete,after undelete,after insert,after update,after delete) {

if(trigger.isAfter){
    if(trigger.isUpdate){
         AccountTriggerHandler.updateRelatedContactPhone(trigger.new,trigger.oldmap);
   }
}

public class with sharing  AccountTriggerHandler{


public static void updateRelatedContactPhone(list<Account> newAccountList,map<id,Account>oldmap){
        set<Id> accountIdSet = new set<Id>();
        if(!newAccountList.isEmpty()){
            for(Account acc : newAccountList){
                if(acc.Id != null && acc.phone != oldmap.get(acc.Id).phone){
                   accountIdSet.add(acc.Id); 
                }
            }
        }
     //  list<Account> aclist = [select Id,phone,(select Id,phone from contacts)from account Where id IN: accountIdSet];
        list<contact> conlist = new list<contact>();
        map<ID,Contact> contactMap = new map<Id,contact>([select accountId,phone from contact where accountId IN:accountIdSet]);
        if(!newAccountList.isEmpty()){
            for(Account acc : newAccountList){
                if(acc.Id != null && acc.phone != oldmap.get(acc.Id).phone && contactMap.containsKey(acc.ID)){
                   contact con = contactMap.get(acc.Id);
                    con.Phone = acc.Phone;
                    conlist.add(con);
                }
            }
        }
        if(!conlist.isEmpty()){
            update conlist;
        }
    }



question No3 :- (parent -child ) 




questions -8 trigger to find sum of all related opportunities amount of an account





question 9:- trigger on account when account is updated check all opportunity related to account. -> update opp stage to close lost if an 
opportunity created date is greater than 30 days from today and stage not euals to close won.




question 10:- prevent a other user from delete account



question 11:- show error when account should not have more than two contact



question 12:- case is inserted on account put the latest case num in account field
Ans:- 

public static void caseNumToAccount(list<Case>newCaseList){

list<Account>acclist = new list<Account>();
if(!newCaseList.isEmpty()){

for(Case cs: newCaseList.isEmpty){
if(cs.AccountId != null){
account acc = new account();
acc.id = cs.AccountId;
acc.newCaseNumber = cs.id;
acclist.add(acc);
}

if(acclist.isEmpty()){
update acclist;
}

}

Approach 1 (List<Account>):

    You are updating a list of Account records at once.
    If there are multiple cases for the same account, you may end up updating the same account multiple times.


so this case also use a map

 public static void updateAccountCaseNumberField(list<Case> newCaseList){
        set<Id>accountIdSet = new set<Id>();
        if(!newCaseList.isEmpty()){
            for(case cs: newCaseList){
                if(cs.AccountId !=null){
                    accountIdSet.add(cs.AccountId);
                }
            }
        }
        map<id,Account> accounToUpdateMap =new map<id,Account>([select id,c__c from account where id In: accountIdSet]);
        list<Account> acclist = new list<Account>();
         if(!newCaseList.isEmpty()){
            for(case cs: newCaseList){
                if(cs.AccountId !=null && accounToUpdateMap.containsKey(cs.AccountId)){
                    Account acc = accounToUpdateMap.get(cs.AccountId);
                    acc.c__c =Decimal.valueOf(cs.id);
                    acclist.add(acc);
                }
            }
        }
        if(!acclist.isEmpty()){
            update acclist;
        }
    }








